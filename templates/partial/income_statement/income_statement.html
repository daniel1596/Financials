<h3>Income statement</h3>

<div id="incomeStatementRoot">
    <form class="container mb-3">
      <div class="row justify-content-center mb-1">
        <label for="startingYearSelect" class="mr-1 mb-0">Start at: </label>
        <select id="startingYearSelect" v-model="selected.startingYear">
            <option v-for="year in [2020, 2019]">[[ year ]]</option>
        </select>
        <select v-model="selected.startingQuarter" v-show="selected.analysisType !== 'Yearly'">
            <option v-for="quarter in [4, 3, 2, 1]" :value="quarter">Q[[ quarter ]]</option>
        </select>
        <div v-show="selected.analysisType !== 'QOQ'">
          <label for="columnCount" class="ml-2 mb-0">How many columns? </label>
          <select v-model="selected.columnCount">
            <option v-for="x in columnCountOptions">[[ x ]]</option>
          </select>
        </div>
      </div>
      <div class="row justify-content-center">
        <span class="ml-2">
            <div class="form-check-inline" v-for="analysisType in analysisTypes">
                <input class="form-check-input" type="radio" :id="'radio' + analysisType" :value="analysisType" v-model="selected.analysisType">
                <label class="form-check-label" :for="'radio' + analysisType">Show [[ analysisType ]]</label>
            </div>
        </span>
      </div>
    </form>
    <div class="container">
      <div id="incomeStatementTable"></div> <!-- Tabulator to inject here -->
    </div>
</div>


<script>
    const incomeStatement = new Vue({
      el: "#incomeStatementRoot",
      delimiters: ['[[', ']]'],  // the default is curly braces, but this would conflict with Jinja syntax
      data: {
        analysisTypes: ['QOQ', 'YOY', 'Yearly'],
        apiUrlBase: "/api/income_statements",
        columnCountOptions: Array(20).fill().map((_,i) => i + 1), // 20 is an arbitrary max, but should be sufficient
        incomeStatementTable: null,
        incomeStatements: [],
        selected: {
          analysisType: 'YOY',
          columnCount: 4,
          startingQuarter: 3,
          startingYear: 2020
        }
      },
      computed: {
        apiUrl: function () {
          const { analysisType, columnCount, startingQuarter, startingYear } = this.selected
          return `${this.apiUrlBase}?starting_year=${startingYear}&starting_quarter=${startingQuarter}&analysisType=${analysisType}&columnCount=${columnCount}`
        }
      },
      watch: {
        // There might be a slightly better way, but I think this watcher is all right. It's much better than it was.
        // We do need it to be deep to update whenever any of the properties (e.g. selected.analysisType) change.
        // And it's a better solution than using an "onchange" attribute for each dropdown/radio button
        // (which was the original attempt at a solution, and didn't work).
        selected: {
          handler: function(newValue, oldValue) {
            this.updateTableData()
          },
          deep: true
        }
      },
      methods: {
        loadData: async function () {
          // In theory, I could add error handling here, checking if the data is [] or false-y
          // However, with such a small app and very limited opportunities for failure, I'm not worrying too much
          // about it right now. Can add later if desired or if errors occur.
          this.incomeStatements = (await axios.get(this.apiUrl)).data
        },
        setupTabulatorTable: function () {
          this.incomeStatementTable = new Tabulator("#incomeStatementTable", {
            data: this.incomeStatements.line_items,
            dataTree: true, // needed for nested table data - see http://tabulator.info/docs/4.7/tree
            columns: [
              { title: "", field: "field", headerSort: false },
            ].concat(this.incomeStatements.dates.map((date, index) => ({
              title: date, field: `value${index}`, headerSort: false, minWidth: 80
            })))
          })
        },
        updateTableData: async function () {
          // It seems like slightly poor form to re-instantiate the Tabulator object each time through,
          // but I'm not sure that it can be avoided. It may be unnecessary work to avoid it.
          // I tried using table.redraw() and table.redraw(true) as well, but I think this or something similar
          // is necessary to actually change the table columns and re-render everything.
          // However, since the amount of JSON data is so small, the JS object is so small,
          // and most importantly, the performance hit seems very minimal, I am inclined to leave it for now.
          await this.loadData()
          this.setupTabulatorTable()
        }
      },
      mounted: async function () {
        await this.updateTableData()
      }
    })
</script>
